This is a file documenting all the functions included in the package. Each heading tangles into a different file, following the bioconductor package rules.

* classes
  :PROPERTIES:
  :header-args: :tangle "./R/AllClasses.R"
  :END:
** CalciumExperiment

#+BEGIN_SRC R
##' Function that defines the CalciumExperiment class
##'
##' 
##' @title CalciumExperiment class
#' @param raw 
#' @param ... 
##' @return 


##' @author Muad Abd El Hay
##'@export
#' @import methods
#' @importClassesFrom SummarizedExperiment SummarizedExperiment
.CalciumExperiment <- setClass("CalciumExperiment", contains = "SummarizedExperiment")

##' Constructor for CalciumExperiment objects.
##'
##' 
##' @title CalciumExperiment constructor
#' @param raw 
#' @param ... 
##' @return A CalciumExperiment object.
##' @author Muad Abd El Hay
##' @export
#' @importFrom SummarizedExperiment SummarizedExperiment
CalciumExperiment <- function(raw, ...) {
  se <- SummarizedExperiment(list(raw=raw), 
                             ...)
  .CalciumExperiment(se)
}

## setValidity2("CalciumExperiment", function(object) {
##   msg <- NULL
##   if (is.null(msg)) {
##     TRUE
##   } else msg
## })
#+END_SRC

** TODO VoltageExperiment
*** CalciumExperiment
    
* generics
  :PROPERTIES:
  :header-args: :tangle "./R/AllGenerics.R"
  :END:
** raw
 #+BEGIN_SRC R


##' Accessor function for raw fluorescence values per ROI
##' @title raw Accessor
#' @param x 
#' @param ... 
##' @return raw fluorescence values.
##' @author Muad Abd El Hay
#' @export
setGeneric("raw", function(x, ...) standardGeneric("raw"))


##' Accessor function for raw fluorescence values per ROI
##' @title raw Accessor
#' @param x 
#' @param withDimnames 
##' @return The raw fluorescence trace of a CalciumExperiment object.
##' @author Muad Abd El Hay
#' @export
#' @importFrom SummarizedExperiment assay
setMethod("raw", "CalciumExperiment", function(x, withDimnames=TRUE) {
    assay(x, withDimnames=withDimnames)
})

 #+END_SRC
** normalize
#+BEGIN_SRC R
#' @title Function to normalize traces.
#' @export
#' @return A CalciumExperiment object with a "normalized" assay.
#' @importFrom BiocGenerics normalize
##' @param object CalciumExperiment object. 
##' @param method character. The method to use for baseline correction. Defaults to "estimateBaseline",
##' @param slot character. Which assay slot to use for baseline correction.
##' @param window numeric. The width of the baseline window to use for dF/F0 calculation. A window of width 500 will take the first 500 frames as baseline.
##' @param ... 
setMethod("normalize", "CalciumExperiment", function(object, type = "estimateBaseline", slot, window, output.name = "normalized", ...) {
  
  non.normalized.data <- SummarizedExperiment::assay(object,slot)
  if (missing(slot)) {
    stop("Chose which assay to normalize by setting the slot argument.")
  }

  if (type == "estimateBaseline") {
    baseline <- estimateBaselines(non.normalized.data, ...)
   d ff <- (non.normalized.data - baseline) / baseline
  }

  if (type == "start") {
    if (missing(window)) {
      stop("No baseline starting window specified.")
    }
    baseline <- apply(non.normalized.data[seq_len(window),],2, mean)
    df <- sweep(non.normalized.data, 2, baseline, "-")
    dff <- sweep(df, 2, baseline, "/")
  }

  assay(object, output.name) <- dff

  return(object)

}
)
#+END_SRC
* importers
  :PROPERTIES:
  :header-args: :tangle "./R/importers.R"
  :END:

** readSuite2p

#+BEGIN_SRC R

##' Load data from suite2p
##'
##' Takes the output of a full suite2p run and turns it into a \linkS4class{CalciumExperiment} object
##' @title Import suite2p outputs
##' @param s2p.path The path to the folder containing suite2p outputs
##' @param time A time vector giving the timepoint at which every frame was taken. If left blank, a vector will be calculated with the fs parameter from Suite2p and the number of frames.
##' @param exp.n Experiment name/number. This is used to give the cells/ROIs unique IDs and will be randomly generated if left blank.
##' @param correction.factor The corection factor for neuropili substraction, defaults to 0.7
##' @param ... 
##' @return A CalciumExperiment object with the data from a Suite2p output folder.
##' @author Muad Abd El Hay
##' @importFrom reticulate import
##' @export
readSuite2p <- function(s2p.path, time, exp.n, correction.factor=0.7, filter = TRUE, ...) {
  
  if(missing(exp.n)) {
    message("No experiment number/name given. Random name will be used.")
    exp.n <- randomAlphaNum()
  }


  np <- reticulate::import("numpy")
  os <- reticulate::import("os.path")
  
  message("Importing extracted fluorescence.")
  f <- np$load(
            os$expanduser(
                 paste(s2p.path,
                       "/plane0/F.npy",
                       sep = "")
               ),
            allow_pickle = TRUE)
  
  message("Importing neuropili traces.")
  fNeu <- np$load(
               os$expanduser(
                    paste(s2p.path,
                          "/plane0/Fneu.npy",
                          sep = "")
                  ),
               allow_pickle = TRUE) 

  isCell <- np$load(
                 os$expanduser(
                      paste(s2p.path,
                            "/plane0/iscell.npy",
                            sep = "")
                    ),
                 allow_pickle = TRUE)
  
  stats <- np$load(
                os$expanduser(
                     paste(s2p.path,
                           "/plane0/stat.npy",
                           sep = "")
                   ),
                allow_pickle = TRUE
              )

  message("Importing deconvoluted traces.")
  spks <- np$load(
               os$expanduser(
                    paste(s2p.path,
                          "/plane0/spks.npy",
                          sep = "")
                  ),
               allow_pickle = TRUE)

  ops <- np$load(
              os$expanduser(
                   paste(s2p.path,
                         "/plane0/ops.npy",
                         sep = "")
                 ),
              allow_pickle = TRUE)

  ops <- ops[[1]]
  
  if (isTRUE(filter)) {

  message("Filtering cells.")
  fT <- t(f[isCell[,1]==1,])
  fNeuT <- t(fNeu[isCell[,1]==1,])
  spksT <- t(spks[isCell[,1]==1,])

    } else {
  message("Taking all ROIs.")    
  fT <- t(f)
  fNeuT <- t(fNeu)
  spksT <- t(spks)    

}

  
    
  if (missing(time)) {
    message(sprintf("No time vector given. Generating time vector with framerate:",ops$fs,"Hz"))
    time <- seq_len(nrow(fT))/ops$fs
  } else {
    if (typeof(time) %in% c("integer","double")) {
      time = time
    } else {
      stop("Time vector supplied is neither double nor integer")  
    }     
  }

  if(!(nrow(fT) == length(time))) {

    stop("Time vector length is not qual to number of frames.")
    
  }
  

  message(sprintf("Calculating corrected traces with factor:", correction.factor, sep=" "))
  fClean <- fT - correction.factor * fNeuT

  if (isTRUE(filter)) {

  stats <- stats[which(isCell[,1] == 1)]
}
  phenoData <-  S4Vectors::DataFrame(cellid = paste(exp.n, seq_len(ncol(fClean)), sep="_"))

  message("Putting together cell parameters.")
  if("radius" %in% names(stats[[1]])) {
    phenoData <- cbind(phenoData, radius = purrr::map_dbl(stats, "radius"))}
  if("npix" %in% names(stats[[1]])) {
    phenoData <- cbind(phenoData, npix = purrr::map_dbl(stats, "npix"))}
  if("npix_norm" %in% names(stats[[1]])) {
    phenoData <- cbind(phenoData, npix_norm = purrr::map_dbl(stats, "npix_norm"))}
  if("med" %in% names(stats[[1]])) {
    phenoData <- cbind(phenoData, centerx = purrr::map_dbl(stats, ~.x$med[[1]]))
    phenoData <- cbind(phenoData, centery = purrr::map_dbl(stats, ~.x$med[[2]]))}
  if("compact" %in% names(stats[[1]])) {
    phenoData <- cbind(phenoData, compactness = purrr::map_dbl(stats, "compact"))}
  if("footprint" %in% names(stats[[1]])) {
    phenoData <- cbind(phenoData, footprint = purrr::map_dbl(stats, "footprint"))}
  if("aspect_ratio" %in% names(stats[[1]])) {
    phenoData <- cbind(phenoData, aspect_ratio = purrr::map_dbl(stats, "aspect_ratio"))}
  if("skew" %in% names(stats[[1]])) {
    phenoData <- cbind(phenoData, skewness = purrr::map_dbl(stats, "skew"))}
  if("std" %in% names(stats[[1]])) {
    phenoData <- cbind(phenoData, std = purrr::map_dbl(stats, "std"))}
  
  xpix <-  purrr::map(stats, "xpix")
  ypix <-  purrr::map(stats, "ypix")
  xypix <- mapply(cbind, xpix, ypix, SIMPLIFY=F)
  xypix <- lapply(xypix, as.data.frame)

  xypix <- Map('+', xypix, 1)
  
  tidymasks <- dplyr::bind_rows(setNames(xypix, seq_along(xypix)), .id = "id")
  
  masks <- matrix(0, nrow = ops$Lx, ncol = ops$Ly)
  
  for (i in seq_len(length(xypix))) {

    cell.xy.pix <- xypix[[i]]
    
    masks[as.matrix(cell.xy.pix)] <- i
  }

  ops$exp.n <- exp.n
  ops$tidymasks <- tidymasks
  ops$masks <- masks
  

  message("Creating CalciumExperiment object.")
  ce <- CalciumExperiment(raw = fT,
                          colData = phenoData,
                          rowData = S4Vectors::DataFrame(time),
                          metadata = ops)

  SummarizedExperiment::assay(ce, "neuropil") <- fNeuT
  SummarizedExperiment::assay(ce, "corrected") <- fClean
  SummarizedExperiment::assay(ce, "deconvoluted") <- spksT

  message("Generating unique cell names.")
  rownames(ce) <- paste("f", seq_len(nrow(ce)), sep="")
  colnames(ce) <- paste(exp.n, seq_len(ncol(ce)), sep="_")

  
  
  return(ce)
}

#+END_SRC



* plotters
  :PROPERTIES:
  :header-args: :tangle "./R/plotters.R"
  :END:

** plotTraces
#+BEGIN_SRC R
##' Plots staggered line plots of each ROI. Defaults to "raw" values without any additional modifications.
##'
##' Can be set to order the traces or even cluster them before plotting. Traces are scaled by default.
##' @title Function to plot CalciumExperiment objects.
#' @param x 
#' @param slot chracter. The assays() slot to use for plotting.
#' @param order logical. Whether to order the cells/ROIs by calculating the sums of the response.
#' @param cluster logical. Whether to clusted the cells/ROIs by correlation. 
##' @return A ggplot2 object with the traces for each cell.
##' @author Muad Abd El Hay
##' @export
#' @importFrom magrittr %>%
#' @importFrom stats cor
#' @importFrom stats hclust
#' @importFrom stats as.dist
#' @importFrom rlang .data
#' @importFrom RColorBrewer brewer.pal
#' @importFrom matrixStats colSums2
#' @import ggplot2
plotTraces <-  function(x, slot="raw", order=FALSE,cluster=FALSE, scale=TRUE) {
  if (slot == "raw"){
    chosen_assay <- raw(x)
  }
  else {
    chosen_assay <- SummarizedExperiment::assays(x)[[slot]]
  }
  
  if (isTRUE(scale)) {
    plotting_data <- colScale(chosen_assay)
  } else {
    plotting_data <- chosen_assay
  }

  if (isTRUE(cluster)) {
    cols.cor <- stats::cor(plotting_data, use = "pairwise.complete.obs", method = "pearson")
    cols.clust <- stats::hclust(stats::as.dist(1 - cols.cor))
    xorder <- cols.clust$order
    plotting_data <- plotting_data[,xorder]
  }

  if (isTRUE(order)) {
    xorder <- order(matrixStats::colSums2(plotting_data))
    plotting_data <- plotting_data[,xorder]
  }
  
  colnames(plotting_data) <- seq_len(ncol(plotting_data))
  
  color.factor <- ceiling(ncol(plotting_data)/9)

  plotting_data %>%
    tibble::as_tibble() %>%    
    dplyr::mutate(frame = seq_len(nrow(.))) %>%
    tidyr::gather(value = value, key = key, -frame) %>%
    dplyr::mutate(numkey = as.numeric(key)) %>% 
    ggplot(aes(x = frame, y = value + numkey, group = key, color = key)) +
    geom_line() +
    scale_colour_manual(values=rep(RColorBrewer::brewer.pal(9,"Set1"),times=color.factor))+
    theme_void() +
    theme(legend.position = "none")
  
}




#+END_SRC


** plotTraces2
#+BEGIN_SRC R
##' Plots staggered line plots of each ROI. Defaults to "raw" values without any additional modifications.
##'
##' Can be set to order the traces or even cluster them before plotting. Traces are scaled by default.
##' @title Function to plot CalciumExperiment objects.
#' @param x 
#' @param slot chracter. The assays() slot to use for plotting.
#' @param order logical. Whether to order the cells/ROIs by calculating the sums of the response.
#' @param cluster logical. Whether to clusted the cells/ROIs by correlation. 
##' @return A ggplot2 object with the traces for each cell.
##' @author Muad Abd El Hay
##' @export
#' @importFrom magrittr %>%
#' @importFrom stats cor
#' @importFrom stats hclust
#' @importFrom stats as.dist
#' @importFrom rlang .data
#' @importFrom RColorBrewer brewer.pal
#' @importFrom matrixStats colSums2
#' @import ggplot2
plotTraces2 <-  function(x, slot="raw", order=FALSE,cluster=FALSE, scale=TRUE) {
  if (slot == "raw"){
    chosen_assay <- raw(x)
  }
  else {
    chosen_assay <- SummarizedExperiment::assays(x)[[slot]]
  }
  
  if (isTRUE(scale)) {
    plotting_data <- colScale(chosen_assay)
  } else {
    plotting_data <- chosen_assay
  }

  if (isTRUE(cluster)) {
    cols.cor <- stats::cor(plotting_data, use = "pairwise.complete.obs", method = "pearson")
    cols.clust <- stats::hclust(stats::as.dist(1 - cols.cor))
    xorder <- cols.clust$order
    plotting_data <- plotting_data[,xorder]
  }

  if (isTRUE(order)) {
    xorder <- order(matrixStats::colSums2(plotting_data))
    plotting_data <- plotting_data[,xorder]
  }
  
  colnames(plotting_data) <- seq_len(ncol(plotting_data))
  
  color.factor <- ceiling(ncol(plotting_data)/9)

  plotting_data %>%
    tibble::as_tibble() %>%    
    dplyr::mutate(frame = seq_len(nrow(.))) %>%
    tidyr::gather(value = value, key = key, -frame) %>%
    dplyr::mutate(numkey = as.numeric(key)) %>% 
    ggplot(aes(x = frame, y = value + numkey, group = key)) +
    geom_path(aes(color = value)) +
    scale_colour_distiller(palette = "Spectral", direction = -1)+
    theme_void() +
    theme(legend.position = "none")
  
}




#+END_SRC



** plotSpikes
#+BEGIN_SRC R
##' Plots staggered barcode plots of each ROI. Defaults to "l0spikes" values without any additional modifications.
##'
##' Can be set to order the traces or even cluster them before plotting. Traces are scaled by default.
##' @title Function to plot spikes from CalciumExperiment objects.
#' @param x 
#' @param slot chracter. The assays() slot to use for plotting.
#' @param order logical. Whether to order the cells/ROIs by calculating the sums of the response.
#' @param cluster logical. Whether to clusted the cells/ROIs by correlation. 
##' @return A ggplot2 object with the predicted pikes for each cell.
##' @author Muad Abd El Hay
##' @export
#' @importFrom magrittr %>%
#' @importFrom stats cor
#' @importFrom stats hclust
#' @importFrom stats as.dist
#' @importFrom rlang .data
#' @importFrom RColorBrewer brewer.pal
#' @importFrom matrixStats colSums2
#' @import ggplot2
plotSpikes <-  function(x, slot="l0spikes", order=FALSE,cluster=FALSE, scale=TRUE) {


  chosen_assay <- SummarizedExperiment::assays(x)[[slot]]
 
  
  if (isTRUE(scale)) {
    plotting_data <- colScale(chosen_assay)
  } else {
    plotting_data <- chosen_assay
  }

  if (isTRUE(cluster)) {
    cols.cor <- stats::cor(plotting_data, use = "pairwise.complete.obs", method = "pearson")
    cols.clust <- stats::hclust(stats::as.dist(1 - cols.cor))
    xorder <- cols.clust$order
    plotting_data <- plotting_data[,xorder]
  }

  if (isTRUE(order)) {
    xorder <- order(matrixStats::colSums2(plotting_data))
    plotting_data <- plotting_data[,xorder]
  }
  
  colnames(plotting_data) <- seq_len(ncol(plotting_data))
  
  color.factor <- ceiling(ncol(plotting_data)/9)

  plotting_data %>%
    tibble::as_tibble() %>%    
    dplyr::mutate(frame = seq_len(nrow(.))) %>%
    tidyr::gather(value = value, key = key, -frame) %>%
    dplyr::mutate(numkey = as.numeric(key)) %>% 
    dplyr::filter(value > 0) %>%
    ggplot(aes(x = frame, y = numkey, group = key, color = key)) +
    geom_point(shape = 108) +
    scale_colour_manual(values=rep(RColorBrewer::brewer.pal(9,"Set1"),times=color.factor))+
    theme_void() +
    theme(legend.position = "none")
  
}




#+END_SRC


** splotSpikes2
#+BEGIN_SRC R

##' Plots staggered barcode plots of each ROI. Defaults to "l0spikes" values without any additional modifications.
##'
##' Can be set to order the traces or even cluster them before plotting. Traces are scaled by default.
##' @title Function to plot spikes from CalciumExperiment objects.
#' @param x 
#' @param slot chracter. The assays() slot to use for plotting.
#' @param order logical. Whether to order the cells/ROIs by calculating the sums of the response.
#' @param cluster logical. Whether to clusted the cells/ROIs by correlation. 
##' @return A ggplot2 object with the predicted pikes for each cell.
##' @author Muad Abd El Hay
##' @export
#' @importFrom magrittr %>%
#' @importFrom stats cor
#' @importFrom stats hclust
#' @importFrom stats as.dist
#' @importFrom rlang .data
#' @importFrom RColorBrewer brewer.pal
#' @importFrom matrixStats colSums2
#' @import ggplot2
plotSpikes2 <-  function(x, slot="l0spikes", order=FALSE,cluster=FALSE, scale=TRUE) {


  chosen_assay <- SummarizedExperiment::assays(x)[[slot]]
 
  
  if (isTRUE(scale)) {
    plotting_data <- colScale(chosen_assay)
  } else {
    plotting_data <- chosen_assay
  }

  if (isTRUE(cluster)) {
    cols.cor <- stats::cor(plotting_data, use = "pairwise.complete.obs", method = "pearson")
    cols.clust <- stats::hclust(stats::as.dist(1 - cols.cor))
    xorder <- cols.clust$order
    plotting_data <- plotting_data[,xorder]
  }

  if (isTRUE(order)) {
    xorder <- order(matrixStats::colSums2(plotting_data))
    plotting_data <- plotting_data[,xorder]
  }
  
  colnames(plotting_data) <- seq_len(ncol(plotting_data))
  
  color.factor <- ceiling(ncol(plotting_data)/9)

  plotting_data %>% 
    tibble::as_tibble() %>%    
    dplyr::mutate(frame = seq_len(nrow(.))) %>%
    tidyr::gather(value = value, key = key, -frame) %>%
    dplyr::mutate(numkey = as.numeric(key)) %>% 
    dplyr::filter(value > 0) %>%
    ggplot(aes(x = frame, y = numkey, group = key, color = key)) +
    geom_point(size = 0.1) +
    scale_colour_manual(values=rep(RColorBrewer::brewer.pal(9,"Set1"),times=color.factor))+
    theme_void() +
    theme(legend.position = "none")
  
}

#+END_SRC

* calculators
  :PROPERTIES:
  :header-args: :tangle "./R/calculators.R"
  :END:

** calculateParameters

#+BEGIN_SRC R
##' Function that takes a MultiAssayExperiment object containings CalciumExperiment objects and calculates parameters for each assay (stimulus).
##' @title Calculate stimulus parameters from a split CalciumExperiment (i.e. MultiAssayExperiment) object.
##' @param mcexp MultiAssayExperiment object containing multiple CalciumExperiment objects (one per stimulus) to calculate from.
##' @param ... 
##' @return A MultiAssayExperiment object with calculated base parameters for each CalciumExperiment object.
##' @export
##' @author Muad Abd El Hay
calculateParameters <- function(mcexp, ...) {

  for (i in seq_len(length(mcexp))) {

    mcexp[[i]] <- getBaseParameters(mcexp[[i]])
  }

return(mcexp)

}



#+END_SRC


** getBaseParameters

#+BEGIN_SRC R  
##' Calculates base parameters of a CalciumExperiment object such as mean, max, min responses as well as number of predicted spikes and location of first spike. 
##' @title Calculate base parameters. 
##' @param cexp CalciumExperiment object to calculate base parameters from. Should be normalized and binarized before running.
##' @param slot 
##' @param binslot 
##' @param ... 
##' @return A CalciumExperiment object with calculated base parameters added to the colData DataFrame
##' @author Muad Abd El Hay
getBaseParameters <-  function(cexp, slot = "normalized", binslot = "l0spikes", ...) {

  if(!(is(cexp, "CalciumExperiment"))) {

    stop("cexp must be of class CalciumExperiment")

  }
  
  if (!("normalized" %in% names(SummarizedExperiment::assays(cexp)))) {
    warning("Chosen assay for parameter calculation is not normalized, are you sure you want to continue?")
  }

  if (!(binslot %in% names(SummarizedExperiment::assays(cexp)))) {
    stop("Chosen binarized assay for parameter calculation is not present, forgot to binarize?")
  }

  normalized.traces <- SummarizedExperiment::assay(cexp, slot)
  binarized.traces <- SummarizedExperiment::assay(cexp, binslot)
  
  stim_mean <- apply(normalized.traces, 2, mean)
  stim_max <- apply(normalized.traces, 2, max)
  stim_min <- apply(normalized.traces, 2, min)
  spikenum <- apply(binarized.traces,2, sum)
  first_spike <- rep(NA, times = ncol(cexp))

  for (i in seq_len(ncol(cexp))) {

    first_spike[i] <- Position( function(x) x > 0, binarized.traces[,i])
  }
  
  base.parameters <- S4Vectors::DataFrame(stim_mean,
                               stim_max,
                               stim_min,
                               spikenum,
                               first_spike)
  
  SummarizedExperiment::colData(cexp) <- cbind(SummarizedExperiment::colData(cexp), base.parameters)
  
  return(cexp)

}

#+END_SRC


** getStimulusParameters

#+BEGIN_SRC R  
##' Calculates stimulus-dependent parameters of a CalciumExperiment object such as stimulus threshold, correlation, and mutual information.
##' @title Calculate base parameters. 
##' @param cexp CalciumExperiment object that has base parameters calculated already. Should be normalized and binarized before running.
##' @param slot The assay slot representing the normalized calcium traces
##' @param binslot The assay slot with the binarized traces
##' @param stimulus.trace The rowData column containing the stimulus to calculate for
##' @param ... 
##' @return A CalciumExperiment object with calculated base parameters added to the colData DataFrame
##' @author Muad Abd El Hay
##' @export
getStimulusParameters <-  function(cexp, slot = "normalized", binslot = "l0spikes", stimulus.trace, ...) {

  if(!(is(cexp, "CalciumExperiment"))) {

    stop("cexp must be of class CalciumExperiment")

  }
  
  if (!("normalized" %in% names(SummarizedExperiment::assays(cexp)))) {
    warning("Chosen assay for parameter calculation is not normalized, are you sure you want to continue?")
  }

  if (!(binslot %in% names(SummarizedExperiment::assays(cexp)))) {
    stop("Chosen binarized assay for parameter calculation is not present, forgot to binarize?")
  }

  normalized.traces <- SummarizedExperiment::assay(cexp, slot)
  binarized.traces <- SummarizedExperiment::assay(cexp, binslot)
  stimulus <-  SummarizedExperiment::rowData(cexp)[,stimulus.trace]

  stimulus.threshold <- rep(NA, times = ncol(cexp))

  for (i in seq_len(ncol(cexp))) {
    if (is.na(SummarizedExperiment::colData(cexp)$first_spike[i])) next
    stimulus.threshold[i] <- stimulus[SummarizedExperiment::colData(cexp)$first_spike[i]]
  }
  
  
  stimulus.parameters <- S4Vectors::DataFrame(stimulus.threshold)
  
  SummarizedExperiment::colData(cexp) <- cbind(SummarizedExperiment::colData(cexp), stimulus.parameters)
  
  return(cexp)

}

#+END_SRC



** binarize

#+BEGIN_SRC R
##' Function to estimate spikes and binarize a CalciumExperiment object.
##' @title Estimate spikes and binarize data using the L0 method by Jewell et al. 2019
##' @param cexp CalciumExperiment object to binarize.
##' @param slot The assay slot to use for binarization. Defaults to "normalized".
##' @param ... Additional parameters that can be passed to the spike estimation function.
##' @return A CalciumExperiment object with an additional assay containig the estimated spikes as 0 and 1 binary.
##' @export
##' @author Muad Abd El Hay
binarize <- function(cexp, slot = "normalized", ...){

  if (slot %in% names(SummarizedExperiment::assays(cexp))) {
    
    normalized.data <- SummarizedExperiment::assay(cexp, slot)

  } else {
    
    stop("no assay with given name found, please normalize the data first with the function normalize or assign another slot to perform binarization on.")
    
  }
  
  estimatedSpikes <- apply(normalized.data, 2, extractSpikesFromLZeroFit)

  colnames(estimatedSpikes) <- colnames(cexp)
  rownames(estimatedSpikes) <- rownames(cexp)
  
  SummarizedExperiment::assay(cexp, "l0spikes") <- estimatedSpikes

  return(cexp)
  
}
#+END_SRC


** estimateFiringRate

#+BEGIN_SRC R

##' A wrapper function for firing rate estimation of binarized CalciumExperiment objects.
##' @title Firing rate estimation from binarized data
##' @param cexp CalciumExperiment object that underwent binarization
##' @param slot Assay slot containing binarized data
##' @param ... Variables passed to the bayesian adaptive kernel smoother (see \link{baks} for more information).
##' @return A CalciumExperiment object with firing rate estimation
##' @author Muad Abd El Hay
##' @export
estimateFiringRate <- function(cexp, slot = "l0spikes", ...){

  if (slot %in% names(SummarizedExperiment::assays(cexp))) {
    
    binarized.data <- SummarizedExperiment::assay(cexp, slot)

  } else {
    
    stop("no assay with given name found, please binarize the data first with the function binarize or assign another slot to perform firing rate estimation on.")
    
  }
  
  estimatedFiringRate <- apply(binarized.data, 2, baks, t = rowData(cexp)$time)

  colnames(estimatedFiringRate) <- colnames(cexp)
  rownames(estimatedFiringRate) <- rownames(cexp)
  
  SummarizedExperiment::assay(cexp, "frs") <- estimatedFiringRate

  return(cexp)
  
}


#+END_SRC

* helpers
  :PROPERTIES:
  :header-args: :tangle "./R/helpers.R"
  :END:

** splitByStimulus  

#+BEGIN_SRC R
##' Takes as input a CalciumExperiment object and a stimulus table that must contain the columns "stimulus", "begin", and "end" denoting the name/number of the stimulus, the beginning of the stimulus and the end, respectively. The stimulus table could either denote the times of stimuli using the units sipplied in the "time" field (check rowData of the CalciumExperiment object) or contain the frame numbers (row numbers) of the stimulus start and end. The default assumes a table contining the times.
##' @title Split CalciumExperiment object into multiple assays by stimuli
##' @param cexp CalciumExperiment to split.
##' @param stim.table The stimulus table with columns "stimulus", "begin", "end" where every row is one stimulus to split the dataset by.
##' @param stim.table.type The type of stimulus table that is supplied. 
##' @param buffer Whether to add a "buffer" before and after the stimulus. Useful for plotting.
##' @param buffer.size The relative size of the buffer. Defaults to half of the stimulus length.
##' @param ... 
##' @importFrom MultiAssayExperiment MultiAssayExperiment
##' @export
##' @return A MultiAssayExperiment object with each stimulus as independent CalciumExperiment object.
##' @author Muad Abd El Hay
splitByStimulus <- function(cexp, stim.table, stim.table.type = "time", buffer = FALSE, buffer.size = 0.5, ...){
  
  if (stim.table.type == "time") {
    
    frame.stim.table <- stim.table
    
    for (i in seq_len(nrow(frame.stim.table))){

      frame.stim.table[i, c("begin")] <- which.min(abs(SummarizedExperiment::rowData(cexp)$time - stim.table[i, c("begin")]))
      frame.stim.table[i, c("end")] <- which.min(abs(SummarizedExperiment::rowData(cexp)$time - stim.table[i, c("end")]))

    }
  } else if (stim.table.type == "frame") {
       
       frame.stim.table <- stim.table
       
  } else {

    stop("Invlid stim.table.type, must be either time or frame")

  }


  if (isTRUE(buffer)) {

    widths <- frame.stim.table$end - frame.stim.table$begin
    buffer.widths <- buffer.size * widths
    frame.stim.table$begin <- frame.stim.table$begin - buffer.widths
    frame.stim.table$end <- frame.stim.table$end + buffer.widths

    frame.stim.table$begin[which(frame.stim.table$begin < 0)] <- 0
    frame.stim.table$end[which(frame.stim.table$end > nrow(cexp))] <- nrow(cexp)

  }
  
  stimulusList <- vector(mode = "list", length = nrow(stim.table))
  names(stimulusList) <- frame.stim.table$stimulus
  
  for (i in seq_len(nrow(frame.stim.table))) {
    
    stimulusList[[i]] <- cexp[seq.int(from = frame.stim.table[i, "begin"], to = frame.stim.table[i,"end"]) ,]

  }
  
  mcexp <- MultiAssayExperiment(experiments=stimulusList, 
                                colData = SummarizedExperiment::colData(stimulusList[[1]]))

  return(mcexp)
}

#+END_SRC

** extractSpikesFromLZeroFit

#+BEGIN_SRC R
##' Utility function to extract the estimated spikes based on the FastLZeroSpikeInference package by Jewell et al. 2019.
##' @title Fit L0 spike inference model and extract spikes according to Jewell et al. 2019
##' @param x A vector containing the normalized fluorescence trace.
##' @param gam numeric. between 0 and 1. Parameter to tune spike inference.
##' @param lambda numeric. between 0 and 1. Parameter to tune spike inference.
##' @param constraint logical. Whether to run the fit with constrain or not.
##' @importFrom FastLZeroSpikeInference estimate_spikes
##' @return A vector containig the estimated spikes as 1s and 0s.
##' @author Muad Abd El Hay
extractSpikesFromLZeroFit <- function(x, gam = 0.8, lambda = 0.1, constraint = FALSE) {

  fit <- FastLZeroSpikeInference::estimate_spikes(x, gam = gam, lambda = lambda, constraint = constraint)
  spikes <- rep(0, times = length(x))
  spikes[fit$spikes] <- 1

  return(spikes)
  
}

#+END_SRC

** colScale
#+BEGIN_SRC R
##' Function for fast center and scaling of matrix columns.
##' @title Fast center and/or scale columns using the matrixStats functions.
##' @param x 
##' @param center 
##' @param scale 
##' @param add_attr 
##' @param rows 
##' @param cols 
##' @return A matrix with scaled columns.
##' @references https://hopstat.wordpress.com/2016/02/23/a-faster-scale-function/
colScale = function(x,
    center = TRUE,
    scale = TRUE,
    add_attr = TRUE,
    rows = NULL,
    cols = NULL) {
 
    if (!is.null(rows) && !is.null(cols)) {
        x <- x[rows, cols, drop = FALSE]
    } else if (!is.null(rows)) {
        x <- x[rows, , drop = FALSE]
    } else if (!is.null(cols)) {
        x <- x[, cols, drop = FALSE]
    }
 
  ################
  # Get the column means
  ################
    cm = matrixStats::colMeans2(x, na.rm = TRUE)
  ################
  # Get the column sd
  ################
    if (scale) {
        csd = matrixStats::colSds(x, center = cm)
    } else {
        # just divide by 1 if not
        csd = rep(1, length = length(cm))
    }
    if (!center) {
        # just subtract 0
        cm = rep(0, length = length(cm))
    }
    x = t( (t(x) - cm) / csd )
    if (add_attr) {
        if (center) {
            attr(x, "scaled:center") <- cm
        }
        if (scale) {
            attr(x, "scaled:scale") <- csd
        }
    }
    return(x)
}

#+END_SRC

#+RESULTS:

** getAUC
#+BEGIN_SRC R

######
#' Calculate the Area Under Curve of y~x
#'
#'@param y Your y values (measures ?)
#'@param x Your x values (time ?)
#'@param start : The first x value 
#'@param stop : The last x value
#'@param na.stop : returns NA if one value is NA
#'@param ex.na.stop : returns NA if the first or the last value is NA
## getAUC <- function(y, x, start=S4Vectors::head(x,1), stop=S4Vectors::tail(x,1), na.stop=FALSE, ex.na.stop=TRUE){
##   if(all(is.na(y))) return(NA)
##   bounds = seq_along(which(x==start):which(x==stop))
##   x=x[bounds]
##   y=y[bounds]
##   r = which(is.na(y))
##   if(length(r)>0){
##     if(na.stop==TRUE) return(NA)
##     if(ex.na.stop==TRUE & (is.na(S4Vectors::first(y)) | is.na(last(y)))) return(NA)
##     if(is.na(last(y))) warning("Last value is NA, so this AUC is bad and you should feel bad", call. = FALSE) 
##     if(is.na(S4Vectors::first(y))) warning("First value is NA, so this AUC is bad and you should feel bad", call. = FALSE) 
##     x = x[-r]
##     y = y[-r]
##   }
##   sum(diff(x[order(x)])*zoo::rollmean(y[order(x)],2))
## }


#+END_SRC
** expSmooth

#+BEGIN_SRC R
##' Function to perform exponential smoothing.
##' @title Exponential smoothing function.
##' @param x 
##' @param alpha 
##' @return 
##' @author Stephen Eglen
##' @references https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/exposmoo.htm
## expSmooth <- function(x, alpha=0.3) {
##   y = x
##   n = length(x)
##   for (i in seq_along(2:n)) {
##     y[i] = (alpha*x[i]) + ((1-alpha)*y[i-1])
##   }
##   y
## }

#+END_SRC

** baks
#+BEGIN_SRC R
##' Helper function to calculate a firing rate estimate using a Bayesian Adaptive Kernel Smoother as suggested by Ahmadi et al. 2018
##' https://doi.org/10.1371/journal.pone.0206794
##' @title Firing Rate Estimation using Bayesian Adaptive Kernel Smoother
##' @param spikes A binarized vector (0 and 1) of spikes
##' @param t A vector of times in seconds, same length as spikes
##' @param a shape parmeter according to Ahmadi et al., defaults to 4
##' @param b scale parameter according to Ahmadi et al., defaults to 0.975
##' @return A vector of firing rate density estimation
##' @author Muad Abd El Hay
baks <- function(spikes, t, a = 4, b = 0.975) {

  if( sum(spikes) == 0) {

    firing_rate = rep(0, length(t))

  } else {

    spike_times <- t[spikes == 1]
    
    n <- length(spike_times)


    
    b <- b**n

    sumnum <- 0

    sumdenom <-  0

    for (i in seq_len(n)) {

      numerator = (((t - spike_times[i])**2)/2 + 1/b)**(-a)
      denominator = (((t - spike_times[i])**2)/2 +1/b)**(-a - 0.5)
      sumnum = sumnum + numerator
      sumdenom = sumdenom + denominator
      h = (gamma(a)/gamma(a + 0.5)) * (sumnum/sumdenom)

      firing_rate = rep(0, length(t))
    }

    for (j in seq_len(n)) {
      k = (1 / (sqrt(2 * pi) * h)) * exp(-((t - spike_times[j])**2) / (2*h**2))
      firing_rate = firing_rate + k                           
    }
  }
  return(firing_rate)
  
}



#+END_SRC
** randomAlphaNum
#+BEGIN_SRC R
##' Helper function to create an assay name when none is supplied.
##' @title Create a random alpha-numeric string of length n.
##' @param n Length of the alphanumeric string.
##' @return A string with random alpha-numerics of length n.
##' @author Muad Abd El Hay
randomAlphaNum <- function(n = 1) {
  a <- do.call(paste0, replicate(5, sample(LETTERS, n, TRUE), FALSE))
  paste0(a, sprintf("%04d", sample(9999, n, TRUE)), sample(LETTERS, n, TRUE))
}

#+END_SRC

** estimateBaselines
#+BEGIN_SRC R
##' Function to estimate baselines using the baseline package. Default method is "irls". For other options refer to the baseline function in the baseline package.
##' @title Function to estimate baselines of traces.
##' @param x 
##' @param method 
##' @param ... 
##' @return A baseline-corrected trace.
##' @author Muad Abd El Hay
##' @importFrom baseline baseline
estimateBaselines <- function(x, method = "modpolyfit", ...) {
  res <- baseline::baseline(t(x), method, ...)
  return(t(res@baseline))
}

#+END_SRC


* archive

** missing frame rate

#+BEGIN_SRC R
  if (missing(time)) {
    if (is.null(fs)) {
      message("No time or framerate given. Generating time vector with framerate 1Hz")
      time <- seq_len(nrow(raw))
      fs <- 1
    } else {
      message(sprintf("No time vector given. Generating time vector with framerate:",fs,"Hz"))
      time <- 1:nrow(raw)/fs
    }
  } else {
    if (typeof(time) %in% c("integer","double")) {
      time = time
    } else {
      stop("Time vector supplied is neither double nor integer")  
    }     
  }
#+END_SRC
** detrending
#+BEGIN_SRC R

library(magrittr)
library(ijtiff)
library(detrendr)

# read
traces <- read.csv("~/Downloads/dummy.txt")
dim(traces)
#> [1] 4045   85

traces <- bla

# transform for detrendr
traces_transformed <- traces %>% 
  as.matrix() %>% 
  ijtiff_img() %>% 
  linescan_to_stack()
dim(traces_transformed)
#> [1]    1   85    1 4045

# detrend
traces_transformed_detrended <- img_detrend_exp(traces_transformed, 
                                                tau = 100, purpose = "FCS")
dim(traces_transformed_detrended)
#> [1]    1   85    1 4045

# transform back
traces_detrended <- stack_to_linescan(traces_transformed_detrended)
dim(traces_detrended)
#> [1] 4045   85    1    1
dim(traces_detrended) <- dim(traces_detrended)[1:2]
dim(traces_detrended)
#> [1] 4045   85


#+END_SRC

** baseline

#+BEGIN_SRC R

library(baseline)

getCorrectedTrace <- function(x, ...) {
  res <- baseline(t(x))
  return(t(res@corrected))

  }




getBaselinePoly <- function(x, method = "modpolyfit", degree = 4) {
  res <- baseline(t(x), method, degree)
  return(t(res@baseline))

  }

baselines <- getBaselines(raw(calexp))

corrected <- (raw(calexp) - baselines) / baselines

##dimnames(corrected) <- dimnames(calexp)

assay(calexp, "dffpoly") <- corrected
#+END_SRC
