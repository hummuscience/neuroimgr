This is a file documenting all the functions included in the package. Each heading tangles into a different file, following the bioconductor package rules.

* classes
  :PROPERTIES:
  :header-args: :tangle "./R/AllClasses.R"
  :END:
** CalciumExperiment

#+BEGIN_SRC R
##' Function that defines the CalciumExperiment class
##'
##' 
##' @title CalciumExperiment class
#' @param raw 
#' @param ... 
##' @return 


##' @author Muad Abd El Hay
##'@export
#' @import methods
#' @importClassesFrom SummarizedExperiment SummarizedExperiment
.CalciumExperiment <- setClass("CalciumExperiment", contains = "SummarizedExperiment")

##' Constructor for CalciumExperiment objects.
##'
##' 
##' @title CalciumExperiment constructor
#' @param raw 
#' @param ... 
##' @return 
##' @author Muad Abd El Hay
##' @export
#' @importFrom SummarizedExperiment SummarizedExperiment
CalciumExperiment <- function(raw, ...) {
  se <- SummarizedExperiment(list(raw=raw), 
                             ...)
  .CalciumExperiment(se)
}

## setValidity2("CalciumExperiment", function(object) {
##   msg <- NULL
##   if (is.null(msg)) {
##     TRUE
##   } else msg
## })
#+END_SRC

** TODO VoltageExperiment
*** CalciumExperiment
    
* generics
  :PROPERTIES:
  :header-args: :tangle "./R/AllGenerics.R"
  :END:
** raw
 #+BEGIN_SRC R


##' Accessor function for raw fluorescence values per ROI
##' @title raw Accessor
#' @param x 
#' @param ... 
##' @return 
##' @author Muad Abd El Hay
#' @export
setGeneric("raw", function(x, ...) standardGeneric("raw"))


##' Accessor function for raw fluorescence values per ROI
##' @title raw Accessor
#' @param x 
#' @param withDimnames 
##' @return 
##' @author Muad Abd El Hay
#' @export
#' @importFrom SummarizedExperiment assay
setMethod("raw", "CalciumExperiment", function(x, withDimnames=TRUE) {
    assay(x, withDimnames=withDimnames)
})

 #+END_SRC
** normalize
#+BEGIN_SRC R
#' @title Function to normalize traces.
#' @export
#' @importFrom BiocGenerics normalize
##' @param object CalciumExperiment object. 
##' @param method character. The method to use for baseline correction. Defaults to "estimateBaseline",
##' @param slot character. Which assay slot to use for baseline correction.
##' @param window numeric. The width of the baseline window to use for dF/F0 calculation. A window of width 500 will take the first 500 frames as baseline.
##' @param ... 
setMethod("normalize", "CalciumExperiment", function(object, method = "estimateBaseline", slot, window, ...) {
  
  non.normalized.data <- assay(object,slot)
  if (missing(slot)) {
    stop("Chose which assay to normalize by setting the slot argument.")
  }

  if (method == "estimateBaseline") {
    baseline <- estimateBaselines(non.normalized.data)
    dff <- (non.normalized.data - baseline) / baseline
  }

  if (method == "start") {
    if (missing(window)) {
      stop("No baseline starting window specified.")
    }
    baseline <- apply(non.normalized.data[1:window,],2, mean)
    df <- sweep(non.normalized.data, 2, baseline, "-")
    dff <- sweep(df, 2, baseline, "/")
  }

  assay(object, "normalized") <- dff

  return(object)

}
)
#+END_SRC
* importers
  :PROPERTIES:
  :header-args: :tangle "./R/importers.R"
  :END:

** readSuite2p

#+BEGIN_SRC R

##' Load data from suite2p
##'
##' Takes the output of a full suite2p run and turns it into a \linkS4class{CalciumExperiment} object
##' @title Import suite2p outputs
##' @param s2p.path The path to the folder containing suite2p outputs
##' @param time A time vector giving the timepoint at which every frame was taken. If left blank, a vector will be calculated with the fs parameter from Suite2p and the number of frames.
##' @param exp.n Experiment name/number. This is used to give the cells/ROIs unique IDs and will be randomly generated if left blank.
##' @param correction.factor The corection factor for neuropili substraction, defaults to 0.7
##' @param ... 
##' @return 
##' @author Muad Abd El Hay
##' @importFrom reticulate import
##' @export
readSuite2p <- function(s2p.path, time, exp.n, correction.factor=0.7, ...) {
  
  if(missing(exp.n)) {
  message("No experiment number/name given. Random name will be used.")
  exp.n <- randomAlphaNum()
  }

  np <- reticulate::import("numpy")
  os <- reticulate::import("os.path")
  
  message("Importing extracted fluorescence.")
  f <- np$load(
            os$expanduser(
                 paste(s2p.path,
                       "/plane0/F.npy",
                       sep = "")
               ),
            allow_pickle = TRUE)
  
  message("Importing neuropili traces.")
  fNeu <- np$load(
               os$expanduser(
                    paste(s2p.path,
                          "/plane0/Fneu.npy",
                          sep = "")
                  ),
               allow_pickle = TRUE) 

  isCell <- np$load(
                 os$expanduser(
                      paste(s2p.path,
                            "/plane0/iscell.npy",
                            sep = "")
                    ),
                 allow_pickle = TRUE)
  
  stats <- np$load(
                os$expanduser(
                     paste(s2p.path,
                           "/plane0/stat.npy",
                           sep = "")
                   ),
                allow_pickle = TRUE
              )

  message("Importing deconvoluted traces.")
  spks <- np$load(
               os$expanduser(
                    paste(s2p.path,
                          "/plane0/spks.npy",
                          sep = "")
                  ),
               allow_pickle = TRUE)

  ops <- np$load(
              os$expanduser(
                   paste(s2p.path,
                         "/plane0/ops.npy",
                         sep = "")
                 ),
              allow_pickle = TRUE)

  ops <- ops[[1]]
  
  message("Filtering cells.")
  fT <- t(f[isCell[,1]==1,])
  fNeuT <- t(fNeu[isCell[,1]==1,])
  spksT <- t(spks[isCell[,1]==1,])

  message(sprintf("Calculating corrected traces with factor:", correction.factor, sep=" "))
  fClean <- fT - correction.factor * fNeuT

  stats <- stats[which(isCell[,1] == 1)]

  message("Putting together cell parameters.")
  cellRadius <- purrr::map_dbl(stats, "radius")
  cellNpix <- purrr::map_dbl(stats, "npix")
  cellNpixNorm <- purrr::map_dbl(stats, "npix_norm")
  ## cellYpix <- purrr::map_dbl(stats, ~.x$ypix[1])
  ## cellXpix <- purrr::map_dbl(stats, ~.x$xpix[1])
  ## cellLam <- purrr::map_dbl(stats, ~.x$lam[1])
  cellCenterX <- purrr::map_dbl(stats, ~.x$med[[1]])
  cellCenterY <- purrr::map_dbl(stats, ~.x$med[[2]])
  cellCompact <- purrr::map_dbl(stats, "compact")
  cellFootprint <- purrr::map_dbl(stats, "footprint")
  cellAspectRatio <- purrr::map_dbl(stats, "aspect_ratio")
  cellSkew <- purrr::map_dbl(stats, "skew")
  cellStd <- purrr::map_dbl(stats, "std")
  
  phenoData <- DataFrame(radius = cellRadius,
                         npix = cellNpix,
                         npix_norm = cellNpixNorm,
                         ## ypix = cellYpix,
                         ## xpix = cellXpix,
                         ## lam = cellLam,
                         centerx <- cellCenterX,
                         centery <- cellCenterY,
                         compactness = cellCompact,
                         footprint = cellFootprint,
                         aspect_ratio = cellAspectRatio,
                         skewness = cellSkew,
                         std = cellStd)
  
  if (missing(time)) {
      message(sprintf("No time vector given. Generating time vector with framerate:",ops$fs,"Hz"))
      time <- 1:nrow(fT)/ops$fs
  } else {
    if (typeof(time) %in% c("integer","double")) {
      time = time
    } else {
      stop("Time vector supplied is neither double nor integer")  
    }     
  }

  ops <- c(exp.n, ops)

  message("Creating CalciumExperiment object.")
  ce <- CalciumExperiment(raw = fT,
                          colData = phenoData,
                          rowData = DataFrame(time),
                          metadata = ops)

  assay(ce, "neuropil") <- fNeuT
  assay(ce, "corrected") <- fClean
  assay(ce, "deconvoluted") <- spksT

  message("Generating unique cell names.")
  rownames(ce) <- paste("f", 1:nrow(ce), sep="")
  colnames(ce) <- paste(exp.n, 1:ncol(ce), sep="_")

  
  
  return(ce)
}

#+END_SRC

* plotters
  :PROPERTIES:
  :header-args: :tangle "./R/plotters.R"
  :END:

** plotTraces
#+BEGIN_SRC R
##' Plots staggered line plots of each ROI. Defaults to "raw" values without any additional modifications.
##'
##' Can be set to order the traces or even cluster them before plotting. Traces are scaled by default.
##' @title Function to plot CalciumExperiment objects.
#' @param x 
#' @param slot chracter. The assays() slot to use for plotting.
#' @param order logical. Whether to order the cells/ROIs by calculating the sums of the response.
#' @param cluster logical. Whether to clusted the cells/ROIs by correlation. 
##' @return 
##' @author Muad Abd El Hay
##' @export
#' @importFrom magrittr %>%
#' @importFrom stats cor
#' @importFrom stats hclust
#' @importFrom stats as.dist
#' @importFrom rlang .data
#' @importFrom RColorBrewer brewer.pal
#' @importFrom matrixStats colSums2
#' @import ggplot2
plotTraces <-  function(x, slot="raw", order=FALSE,cluster=FALSE, scale=TRUE) {
  if (slot == "raw"){
    chosen_assay <- raw(x)
  }
  else {
    chosen_assay <- assays(x)[[slot]]
  }
  
  if (isTRUE(scale)) {
    plotting_data <- colScale(chosen_assay)
  } else {
    plotting_data <- chosen_assay
  }

  if (isTRUE(cluster)) {
    cols.cor <- cor(plotting_data, use = "pairwise.complete.obs", method = "pearson")
    cols.clust <- hclust(as.dist(1 - cols.cor))
    xorder <- cols.clust$order
    plotting_data <- plotting_data[,xorder]
  }

  if (isTRUE(order)) {
    xorder <- order(matrixStats::colSums2(plotting_data))
    plotting_data <- plotting_data[,xorder]
  }
  
  colnames(plotting_data) <- 1:ncol(plotting_data)
  
  color.factor <- ceiling(ncol(plotting_data)/9)

  plotting_data %>%
    tibble::as_tibble() %>%    
    dplyr::mutate(frame = 1:nrow(.)) %>%
    tidyr::gather(value = value, key = key, -frame) %>%
    dplyr::mutate(numkey = as.numeric(key)) %>% 
    ggplot(aes(x = frame, y = value + numkey, group = key, color = key)) +
    geom_line() +
    scale_colour_manual(values=rep(RColorBrewer::brewer.pal(9,"Set1"),times=color.factor))+
    theme_void() +
    theme(legend.position = "none")
  
}




#+END_SRC

* helpers
  :PROPERTIES:
  :header-args: :tangle "./R/helpers.R"
  :END:

** splitByStimulus  

#+BEGIN_SRC R
##' Takes as input a CalciumExperiment object and a stimulus table that must contain the columns "stimulus", "begin", and "end" denoting the name/number of the stimulus, the beginning of the stimulus and the end, respectively. The stimulus table could either denote the times of stimuli using the units sipplied in the "time" field (check rowData of the CalciumExperiment object) or contain the frame numbers (row numbers) of the stimulus start and end. The default assumes a table contining the times.
##' @title Split CalciumExperiment object into multiple assays by stimuli
##' @param cexp CalciumExperiment to split.
##' @param stim.table The stimulus table with columns "stimulus", "begin", "end" where every row is one stimulus to split the dataset by.
##' @param stim.table.type The type of stimulus table that is supplied. 
##' @param buffer Whether to add a "buffer" before and after the stimulus. Useful for plotting.
##' @param buffer.size The relative size of the buffer. Defaults to half of the stimulus length.
##' @param ... 
##' @importFrom MultiAssayExperiment MultiAssayExperiment
##' @export
##' @return A MultiAssayExperiment object with each stimulus as independent CalciumExperiment object.
##' @author Muad Abd El Hay
splitByStimulus <- function(cexp, stim.table, stim.table.type = "time", buffer = FALSE, buffer.size = 0.5, ...){

  if (stim.table.type == "time") {
    
    frame.stim.table <- stim.table
    
    for (i in 1:nrow(frame.stim.table)){

      frame.stim.table[i, c("begin")] <- which.min(abs(rowData(cexp)$time - stim.table[i, c("begin")]))
      frame.stim.table[i, c("end")] <- which.min(abs(rowData(cexp)$time - stim.table[i, c("end")]))

    }
  } else if (stim.table.type == "frame") {
       
       frame.stim.table <- stim.table
       
  } else {

    stop("Invlid stim.table.type, must be either time or frame")

  }


  if (isTRUE(buffer)) {

    widths <- frame.stim.table$end - frame.stim.table$begin
    buffer.widths <- buffer.size * widths
    frame.stim.table$begin <- frame.stim.table$begin - buffer.widths
    frame.stim.table$end <- frame.stim.table$end + buffer.widths

    frame.stim.table$begin[which(frame.stim.table$begin < 0)] <- 0
    frame.stim.table$end[which(frame.stim.table$end > nrow(cexp))] <- nrow(cexp)

  }
  
  stimulusList <- vector(mode = "list", length = nrow(stim.table))
  names(stimulusList) <- frame.stim.table$stimulus
  
  for (i in 1:nrow(frame.stim.table)) {
    
    stimulusList[[i]] <- cexp[frame.stim.table[i,"begin"]:frame.stim.table[i,"end"],]

  }
  
  mcexp <- MultiAssayExperiment(experiments=stimulusList, 
                                colData = colData(stimulusList[[1]]))

  return(mcexp)
}

#+END_SRC

** binarize

#+BEGIN_SRC R
##' Function to estimate spikes and binarize a CalciumExperiment object.
##' @title Estimate spikes and binarize data using the L0 method by Jewell et al. 2019
##' @param cexp CalciumExperiment object to binarize.
##' @param slot The assay slot to use for binarization. Defaults to "normalized".
##' @param ... Additional parameters that can be passed to the spike estimation function.
##' @return
##' @export
##' @author Muad Abd El Hay
binarize <- function(cexp, slot = "normalized", ...){

  if (slot %in% names(assays(cexp))) {
    
    normalized.data <- assay(cexp, slot)

  } else {
    
    stop("no assay with given name found, please normalize the data first with the function normalize or assign another slot to perform binarization on.")
    
  }
  
  estimatedSpikes <- apply(normalized.data, 2, extractSpikesFromLZeroFit)

  colnames(estimatedSpikes) <- colnames(cexp)
  rownames(estimatedSpikes) <- rownames(cexp)
  
  assay(cexp, "l0spikes") <- estimatedSpikes

  return(cexp)
  
}
#+END_SRC

** extractSpikesFromLZeroFit

#+BEGIN_SRC R
##' Utility function to extract the estimated spikes based on the FastLZeroSpikeInference package by Jewell et al. 2019.
##' @title Fit L0 spike inference model and extract spikes according to Jewell et al. 2019
##' @param x A vector containing the normalized fluorescence trace.
##' @param gam numeric. between 0 and 1. Parameter to tune spike inference.
##' @param lambda numeric. between 0 and 1. Parameter to tune spike inference.
##' @param constraint logical. Whether to run the fit with constrain or not.
##' @importFrom FastLZeroSpikeInference estimate_spikes
##' @return 
##' @author Muad Abd El Hay
extractSpikesFromLZeroFit <- function(x, gam = 0.8, lambda = 0.1, constraint = FALSE) {

  fit <- estimate_spikes(x, gam = gam, lambda = lambda, constraint = constraint)
  spikes <- rep(0, times = length(x))
  spikes[fit$spikes] <- 1

  return(spikes)
  
}

#+END_SRC

** colScale
#+BEGIN_SRC R
##' Function for fast center and scaling of matrix columns.
##' @title Fast center and/or scale columns using the matrixStats functions.
##' @param x 
##' @param center 
##' @param scale 
##' @param add_attr 
##' @param rows 
##' @param cols 
##' @return 
##' @references https://hopstat.wordpress.com/2016/02/23/a-faster-scale-function/
colScale = function(x,
    center = TRUE,
    scale = TRUE,
    add_attr = TRUE,
    rows = NULL,
    cols = NULL) {
 
    if (!is.null(rows) && !is.null(cols)) {
        x <- x[rows, cols, drop = FALSE]
    } else if (!is.null(rows)) {
        x <- x[rows, , drop = FALSE]
    } else if (!is.null(cols)) {
        x <- x[, cols, drop = FALSE]
    }
 
  ################
  # Get the column means
  ################
    cm = matrixStats::colMeans2(x, na.rm = TRUE)
  ################
  # Get the column sd
  ################
    if (scale) {
        csd = matrixStats::colSds(x, center = cm)
    } else {
        # just divide by 1 if not
        csd = rep(1, length = length(cm))
    }
    if (!center) {
        # just subtract 0
        cm = rep(0, length = length(cm))
    }
    x = t( (t(x) - cm) / csd )
    if (add_attr) {
        if (center) {
            attr(x, "scaled:center") <- cm
        }
        if (scale) {
            attr(x, "scaled:scale") <- csd
        }
    }
    return(x)
}

#+END_SRC

#+RESULTS:


** expSmooth

#+BEGIN_SRC R
##' Function to perform exponential smoothing.
##' @title Exponential smoothing function.
##' @param x 
##' @param alpha 
##' @return 
##' @author Stephen Eglen
##' @references https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/exposmoo.htm
expSmooth <- function(x, alpha=0.3) {
  y = x
  n = length(x)
  for (i in 2:n) {
    y[i] = (alpha*x[i]) + ((1-alpha)*y[i-1])
  }
  y
}

#+END_SRC


** randomAlphaNum
#+BEGIN_SRC R

randomAlphaNum <- function(n = 1) {
  a <- do.call(paste0, replicate(5, sample(LETTERS, n, TRUE), FALSE))
  paste0(a, sprintf("%04d", sample(9999, n, TRUE)), sample(LETTERS, n, TRUE))
}

#+END_SRC


** estimateBaselines
#+BEGIN_SRC R
##' Function to estimate baselines using the baseline package. Default method is "irls". For other options refer to the baseline function in the baseline package.
##' @title Function to estimate baselines of traces.
##' @param x 
##' @param method 
##' @param ... 
##' @return 
##' @author Muad Abd El Hay
##' @importFrom baseline baseline
estimateBaselines <- function(x, method = "irls", ...) {
  res <- baseline(t(x), method, ...)
  return(t(res@baseline))
}

#+END_SRC

* archive

** missing frame rate

#+BEGIN_SRC R
  if (missing(time)) {
    if (is.null(fs)) {
      message("No time or framerate given. Generating time vector with framerate 1Hz")
      time <- 1:nrow(raw)
      fs <- 1
    } else {
      message(sprintf("No time vector given. Generating time vector with framerate:",fs,"Hz"))
      time <- 1:nrow(raw)/fs
    }
  } else {
    if (typeof(time) %in% c("integer","double")) {
      time = time
    } else {
      stop("Time vector supplied is neither double nor integer")  
    }     
  }
#+END_SRC
** detrending
#+BEGIN_SRC R

library(magrittr)
library(ijtiff)
library(detrendr)

# read
traces <- read.csv("~/Downloads/dummy.txt")
dim(traces)
#> [1] 4045   85

traces <- bla

# transform for detrendr
traces_transformed <- traces %>% 
  as.matrix() %>% 
  ijtiff_img() %>% 
  linescan_to_stack()
dim(traces_transformed)
#> [1]    1   85    1 4045

# detrend
traces_transformed_detrended <- img_detrend_exp(traces_transformed, 
                                                tau = 100, purpose = "FCS")
dim(traces_transformed_detrended)
#> [1]    1   85    1 4045

# transform back
traces_detrended <- stack_to_linescan(traces_transformed_detrended)
dim(traces_detrended)
#> [1] 4045   85    1    1
dim(traces_detrended) <- dim(traces_detrended)[1:2]
dim(traces_detrended)
#> [1] 4045   85


#+END_SRC

** baseline

#+BEGIN_SRC R

library(baseline)

getCorrectedTrace <- function(x, ...) {
  res <- baseline(t(x))
  return(t(res@corrected))

  }




getBaselinePoly <- function(x, method = "modpolyfit", degree = 4) {
  res <- baseline(t(x), method, degree)
  return(t(res@baseline))

  }

baselines <- getBaselines(raw(calexp))

corrected <- (raw(calexp) - baselines) / baselines

##dimnames(corrected) <- dimnames(calexp)

assay(calexp, "dffpoly") <- corrected
#+END_SRC
